<HTML>
<head> <title>CSCI 460 Project - Phase II</title> </head>
<BODY >

<H2>Project - Phase II: Process Management</H2>
<H3>
CSCI 460: Operating Systems
<br>
Spring 2009, Zemoudeh
<br>
Department of Computer Science and Engineering
<br>
California State University, San Bernardino
</H3>

<br>

<P>
In this phase we will add
the process management layer to our OS,
converting the single-user OS of phase I to
a batch-time-sharing OS.
Under your home directory create a <code>cs460</code> directory, under that directory create a <code>phase2</code>
directory, copy all your code and data from phase I to <code>phase2</code>
directory. Modify, implement, and run the new version of the OS
in <code>phase2</code> directory without changing your old code from phase I.

<P>
Every program consists of 5 files with
the same name but suffixes  <code>.s, .o, .in, .out,</code> and <code>.st.</code> For example, the factorial
program consists of <code>fact.s, fact.o, fact.in, fact.out,</code> and <code>fact.st.</code> The <code>.s</code> and <code>.in</code>
files must exist before starting the OS. They hold the assembly
program and its input
respectively.
<code>.o</code> file has to be generated by the OS for each <code>.s</code> file
through a call to the assembler.
<code>.out</code> file is created by the OS and contains the output of the
program. <code>.st</code> file is an input/output file and contains the stack when the
process is not running;
only one stack (of the running program) at a time resides in memory.
When VM is allocated to a process, its stack is read into
high memory from its <code>.st</code> file; and when a process relinquishes VM,
its stack
is written onto its <code>.st</code> file.
By examining the value of <code>sp</code> register, the OS can tell whether
<code>.st</code> file has to be saved.
Remove this file when its corresponding process halts.

<P>
When the OS comes up it looks in the
current directory and gathers all <code>.s</code> files:

<pre>
     system("ls *.s &gt; progs");
</pre>

It then opens <code>progs</code> and reads the file names.
Each file is  assembled, its object code loaded
in memory, and a pointer to its PCB is stored in a linked-list:

<PRE>
     list&lt;PCB *&gt; pcb;
     PCB * p = new PCB;
     pcb.push_back(p);
</PRE>

In this phase of the project the degree of multiprogramming is the same as the
number of <code>.s</code> files in the current directory (in <code>progs</code>).
The processes are resident in memory
until the OS halts. The processes (PCBs) are either in the ready, waiting,
or running state. Maintain two queues of processes, Ready Queue and Wait Queue.

The queues are of type pointer to PCB:

<pre>
     queue&lt;PCB *&gt; readyQ, waitQ;
</pre>

So is the running process:

<pre>
     PCB * running;
</pre>

Pointers in <code>readyQ, waitQ,</code> and <code>running</code> point to a PCB in
the linked-list of PCBs (<code>pcb</code>).
Initially all processes are pushed on the <code>readyQ</code>.
/bin/bash: indent: command not found
When a process is assigned to the VM and it starts running, it either
completes its time slice, when it will be added to the end of <code>readyQ</code>;
or it executes an I/O operation (<code>read</code> or <code>write</code> instruction),
when it will be added to the end of <code>waitQ</code>.
Therefore, a call to the VM by the OS returns either 
<br>
a. time slice is over,
<br>
b. an I/O operation is encountered,
<br>
c. <code>halt</code> instruction is encountered, 
<br>
d. an out-of-bound reference is made,
<br>
e. stack overflows,
<br>
f. stack underflows, or
<br>
g. an invalid opcode is executed.
<br>
The VM sets the status register based on the above conditions and the OS examines it to know how the previous process
relinquished VM. As a result, in this phase, <code>sr</code> is modified to include VM Return-status encoded in 3 bits:

<P>

<style type="text/css">
table.sample1 {
	border-width: 0px;
	border-spacing: ;
	border-style: outset;
	border-color: gray;
	border-collapse: collapse;
	background-color: white;
}
table.sample1 th {
	border-width: 1px;
	padding: 1px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
table.sample1 td {
	border-width: 0px;
	padding: 5px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
</style>
<table class="sample1">
<tr>
<th> &nbsp; d &nbsp; </th>
<th> &nbsp; ... &nbsp; </th>
<th> &nbsp; d &nbsp; </th>
<th> &nbsp; VM Return-status &nbsp; </th>
<th> &nbsp; V &nbsp; </th>
<th> &nbsp; L &nbsp; </th>
<th> &nbsp; E &nbsp; </th>
<th> &nbsp; G &nbsp; </th>
<th> &nbsp; C &nbsp; </th>
</tr>
<tr>
<td> &nbsp; 15  </td>
<td> &nbsp; </td>
<td> &nbsp; 8  </td>
<td> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7:5  </td>
<td> &nbsp; 4  </td>
<td> &nbsp; 3  </td>
<td> &nbsp; 2  </td>
<td> &nbsp; 1  </td>
<td> &nbsp; 0  </td>
</tr>
</table>

These three bits in <code>sr</code> are treated as follows:
<br>
<table>
<tr> <td> <strong> VM Return-status <td> <strong> &nbsp; Meaning
<tr> <td> 000 <td> &nbsp; Time slice
<tr> <td> 001 <td> &nbsp; I/O Operation
<tr> <td> 010 <td> &nbsp; Halt Instruction
<tr> <td> 011 <td> &nbsp; Out-of-bound Reference
<tr> <td> 100 <td> &nbsp; Stack Overflow
<tr> <td> 101 <td> &nbsp; Stack Underflow
<tr> <td> 110 <td> &nbsp; Invalid Opcode
<tr> <td> 111 <td> &nbsp; Unused
</table>

<P>
Any time the VM returns (one of the above seven conditions occurs) a context switch
takes place and the scheduler reorganizes the queues.
Context switch takes 5 clock ticks (all CPU time). During this time
<br>
<B>first,</B> all the processes
in <code>waitQ</code> whose I/O operation has been completed
are placed in <code>readyQ</code>,
<br>
<B>second</B> the running process is placed in the proper queue or terminated,
and 
<br>
<B>third</B> the next
process from <code>readyQ</code> is assigned to VM (CPU).

<P>
I/O requests could immediately occur in the PCB. When an I/O operations is encountered,
immediately perform the I/O (<code>read</code> or <code>write</code> instruction)
in the PCB, move the PCB to <code>waitQ</code>, and set the interrupt
(I/O completion) time to <code>clock + 28</code>. During the
context switch, if the I/O completion time of a process in <code>waitQ</code> is less than or equal to the current time
(the I/O interrupt has arrived),
its PCB is moved to the <code>readyQ</code>.
If all processes are waiting on I/O (<code>readyQ</code> is empty),
you must add as many clock ticks to the clock 
to match the time of completion of the earliest I/O request, at which point
that process will be ready for execution and is moved to <code>readyQ</code> and then to running state.
This is counted as idle time and decreases CPU utilization, see below.
If the time slice of a process is over in the middle of <code>load</code> or
<code>store</code> instructions,
finish the instruction first and then perform the context switch.
Any time this occurs,
effectively the time slice of the process is extended by at
most 3 clock ticks.

<P>
All memory references made by a process have to be
checked against its <code>base</code> and <code>limit</code> values. If an out-of-bound reference
is made, the program is terminated and an appropriate message must appear in the <code>.out</code> file.
Note all addresses have to be an offset from <code>base</code>;
at run time add the <code>base</code> to the addresses for
<code>load</code>,
<code>store</code>,
<code>call</code>,
and the <code>jump</code> instructions.

<P>
Each PCB should at least include <code>pc</code>, <code>r[0]-r[3]</code>, <code>sr</code>,
<code>sp</code>, <code>base</code>, <code>limit</code>, process name, 
<code>fstream</code>s associated with the <code>.o</code>, <code>.in</code>, <code>.out</code>,
and <code>.st</code> files, and the following 
accounting information: VM (CPU) Time, Waiting Time, Turnaround Time,
I/O Time, and the Largest Stack Size.
The accounting information for each process must appear
at the end of the <code>.out</code> file.
Also VM Utilization and Throughput must appear
at the end of each <code>.out</code> file after the process
specific accounting information.

<P>
The definitions of the accounting information as they pertain to 
this phase are:

<P>
Process Specific:

<br>
CPU Time: number of clock ticks the process executes in CPU.

<br>
<code>read</code> and <code>write</code> each take 2 CPU clock tick and 26 I/O clock ticks.

<br>
Waiting Time: number of clock ticks spent in <code>readyQ</code>.

<br>
Turnaround Time: time up to and including the <code>halt</code> instruction execution.

<br>
I/O Time: number of clock ticks spent in <code>waitQ</code>.

<br>
Largest Stack Size: largest number of memory locations allocated to the stack.

<P>
System Information:

<br>
CPU Utilization: percent of the time CPU is busy.

<br>
Throughput: number of processes completed per second. Assume 1 second = 1000 clock ticks.

<P>
All times are summarized in the following table:

<P>
<style type="text/css">
table.sample {
	border-width: 1px;
	border-spacing: ;
	border-style: outset;
	border-color: gray;
	border-collapse: collapse;
	background-color: white;
}
table.sample th {
	border-width: 1px;
	padding: 5px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
table.sample td {
	border-width: 1px;
	padding: 5px;
	border-style: inset;
	border-color: gray;
	background-color: white;
	-moz-border-radius: ;
}
</style>

<table class="sample">
<tr> <th> load/store instr <th> read/write instr <th> all other instr <th> time slice     <th> context switch <th> 1 second </tr>
<tr> <td> 4 clock ticks    <td> 28 clock ticks  <td> 1 clock tick    <td> 15 clock ticks <td> 5 clock ticks <td> 1000 ticks </tr>
</table>

<P>
Your <code>OS</code> class could be a <code>friend</code> of the <code>VirtualMachine</code> class
so that for each process the state of the VM
can be loaded from or stored to its PCB by the OS.

<P>
Run your OS for 6 programs as follows:

<br>
(From phase I) <code>fact1.s</code> with <code>fact1.in</code> content being 6

<br>
(From phase I) <code>fact2.s</code> with <code>fact2.in</code> content being 3

<br>
(From phase I) <code>sub.s</code> the subtract 2 program 

<br>
<code>sum1.s</code> with <code>sum1.in</code> content being 50

<br>
<code>sum2.s</code> with <code>sum2.in</code> content being 101

<br>
<code>io.s</code> with <code>io.in</code> content being 0 1 2 3 4 5 6 7 8 9 10 11

<P>
The <code>sum</code> program is as follows:

<PRE>
    loadi  0 1   ! i = 1
    loadi  1 0   ! sum = 0
    read   2
    compr  0 2
    jumpe  8     ! done
    add    1 0   ! sum += i
    addi   0 1   ! i++
    jump   3     ! loop again
    write  1
    halt
</PRE>

The <code>io.s</code> program is as follows:

<PRE>
    loadi  0 0   ! i = 0
    compri 0 6   ! 6 pairs to read
    jumpe  9     ! i == 6 done
    read   1
    read   2
    add    1 2
    write  1
    addi   0 1   ! i++
    jump   1     ! loop again
    halt
</PRE>

Implement your program incrementally. 
<br>
First, modify your OS to
run only two programs without
any I/O (just compute intensive <code>.s</code> programs).
<br>
Second, modify your OS to handle programs with I/O.
<br>
Third, try several compute
and I/O intensive programs.
<br>
Fourth, modify your OS to gather accounting information.
<br>
Fifth, modify your OS to handle programs with subroutine calls (which grow
stack).

<P>
Demonstrate your program and
hand in printouts of your source code
including the OS, the new VM, and the assembler, and all <code>.s</code>,
<code>.o</code>, <code>.in</code>, and <code>.out</code> files.
The same grading criteria as phase I holds.
</BODY>
</HTML>
